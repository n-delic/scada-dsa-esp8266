#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
//#include <unistd.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

//#include "driver/uart.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "driver/pwm.h"
#include "NTC.h"
#include "KY-033-Hunt.h"
#include "mqtt_client.h"

#include <stdint.h>
#include <stddef.h>
#include "esp_wifi.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include "esp_event.h"
#include "esp_netif.h"
#include "SG90.h"


#include "freertos/semphr.h"
#include "freertos/queue.h"

#include "lwip/sockets.h"
#include "lwip/dns.h"
#include "lwip/netdb.h"

#include "esp_log.h"
#include "mqtt_client.h"
#include "protocol_examples_common.h"

//#include "MyTimer.h"
//#include "esp_timer.h"
//#include "esp_log.h"
//#include "esp_task_wdt.h"

#define PWM_PERIOD 20000

//void adc_task();

static const char *TAG = "MQTT_EXAMPLE";





char* Left; 
char* Right;

int NumOfDigits(int number)
{
	int numDigi = 0;
	number = number / 10;
	while (number != 0)
	{
		numDigi++;
		number = number / 10;
	}
	numDigi++;
	return numDigi;
}

//Returned char* must be freed from memory 
char* AddStrings(char* string1, char* string2)
{
	char* buff = (char*)malloc((strlen(string1) + strlen(string2) + 1) * sizeof(char));

	buff[strlen(string1) + strlen(string2)] = '\0';

	for (int i = 0; i < strlen(string1); i++)
	{
		buff[i] = string1[i];
	}
	for (int i = strlen(string1), j = 0; j < strlen(string2); i++, j++)
	{
		buff[i] = string2[j];
	}

	return buff;
}

//Returned char* must be freed from memory 
char* AddStringNum(char* string1, int number)
{
	char* buff = (char*)malloc((strlen(string1) + NumOfDigits(number) + 1) * sizeof(char));

	buff[strlen(string1) + NumOfDigits(number)] = '\0';

	for (int i = 0; i < strlen(string1); i++)
	{
		buff[i] = string1[i];
	}
    
    
	char* numStr = (char*)malloc((NumOfDigits(number) + 1) * sizeof(char));
	numStr[NumOfDigits(number)] = '\0';
    
	sprintf(numStr, "%d", number);
    
	for (int i = strlen(string1), j = 0; j < NumOfDigits(number); i++, j++)
	{
		buff[i] = numStr[j];
	}

	free(numStr);
	return buff;
}


void SplitString(char c, char* toSplit)
{
	//Fill Left string till we hit char (include char in Left string!!!)


	if (strlen(toSplit) > 0)
	{

		Left = (char*)malloc(1 * sizeof(char));

		int currentIndex = 0;
		for (int i = 0; i < strlen(toSplit); i++)
		{

			//If we entered more than once then reallocate memory (increase memory by one char)
			if (i > 0)
			{
				Left = realloc(Left, i + 1);
			}

			//Append value of char c to allocated memory char
			if (toSplit[i] != c)
			{
				Left[i] = toSplit[i];
			}
			//If we hit char c then exit from alg loop for left string
			else
			{
				currentIndex = i;
				break;
			}
		}

		Left[currentIndex] = '\0';

		Right = (char*)malloc(1 * sizeof(char));

		//Grab all existing chars from right side
		for (int i = currentIndex + 1, j = 0; i < strlen(toSplit); i++, j++)
		{

			//If we entered more than once then reallocate memory (increase memory by one char)
			if (j > 0)
			{
				Right = realloc(Right, j + 1);
			}

			if (toSplit[i] != '\0')
			{
				Right[j] = toSplit[i];
				currentIndex = j;

			}
			else
			{
				break;
			}
		}
		Right = realloc(Right, currentIndex + 2);
		Right[currentIndex + 1] = '\0';

	}


}






void pwm_task();


uint32_t duties[1] = 
{
	15000
};
float phase[1] = 
{
	0,
};

const uint32_t pin_num[1] = 
{
	5,
};

void pwm_task()
{


	


}


void parseReceive(char* data, int data_len)
{
	printf("Primio data i parsiram \n");
	printf("DATA=%.*s\r\n", data_len, data);
	
	SplitString('#', data);
	printf("Received: Lef: %s  Right: %s \n", Left, Right);
	
	//Detect which sensor to affect
	if (!strcmp(Left, "SG0"))
	{
		char parsedEFUSE[1];
		
		parsedEFUSE[0] = Right[0];

		printf("Parsed EFUSE: %s", parsedEFUSE);
		
		uint8_t vrijednost = (uint8_t)strtol(parsedEFUSE, NULL, 10);

		if (vrijednost == 1)
		{
			for (uint8_t i = 0; i < 90; i++)
			{
				printf("Pomjeram na 90\n");
				MoveSG90(i);
				vTaskDelay(50 / portTICK_PERIOD_MS);
			}
			
			
		}
		else
		{
				
			for (uint8_t i = 90; i > 0; i--)
			{
				printf("Pomjeram na 0\n");
				MoveSG90(i);
				vTaskDelay(50 / portTICK_PERIOD_MS);
			}
		}
	}
}
static esp_err_t mqtt_event_handler_cb(esp_mqtt_event_handle_t event)
{
	esp_mqtt_client_handle_t client = event->client;
	int msg_id;
	switch (event->event_id) {
	case MQTT_EVENT_CONNECTED:
		ESP_LOGI(TAG, "MQTT_EVENT_CONNECTED");
		msg_id = esp_mqtt_client_subscribe(client, "/esp/0", 0);
		ESP_LOGI(TAG, "sent subscribe successful, msg_id=%d", msg_id);
		break;
	case MQTT_EVENT_DISCONNECTED:
		ESP_LOGI(TAG, "MQTT_EVENT_DISCONNECTED");
		break;

	case MQTT_EVENT_SUBSCRIBED:
		ESP_LOGI(TAG, "MQTT_EVENT_SUBSCRIBED, msg_id=%d", event->msg_id);
		break;
	case MQTT_EVENT_UNSUBSCRIBED:
		ESP_LOGI(TAG, "MQTT_EVENT_UNSUBSCRIBED, msg_id=%d", event->msg_id);
		break;
	case MQTT_EVENT_PUBLISHED:
		ESP_LOGI(TAG, "MQTT_EVENT_PUBLISHED, msg_id=%d", event->msg_id);
		break;
	case MQTT_EVENT_DATA:
		ESP_LOGI(TAG, "MQTT_EVENT_DATA");
		printf("TOPIC=%.*s\r\n", event->topic_len, event->topic);
		printf("DATA=%.*s\r\n", event->data_len, event->data);
		
		parseReceive(event->data, event->data_len);
		break;
	case MQTT_EVENT_ERROR:
		ESP_LOGI(TAG, "MQTT_EVENT_ERROR");
		break;
	default:
		ESP_LOGI(TAG, "Other event id:%d", event->event_id);
		break;	
	}
	return ESP_OK;
}

static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) {
	ESP_LOGD(TAG, "Event dispatched from event loop base=%s, event_id=%d", base, event_id);
	mqtt_event_handler_cb(event_data);
}








void app_main()
{
	//xTaskCreate(adc_task, "adc_task", 1024, NULL, 10, NULL);
	//xTaskCreate(pwm_task, "pwm_task", 1024, NULL, 10, NULL);
	
	ESP_ERROR_CHECK(nvs_flash_init());
	ESP_ERROR_CHECK(esp_netif_init());
	ESP_ERROR_CHECK(esp_event_loop_create_default());
	ESP_ERROR_CHECK(example_connect());

	esp_mqtt_client_config_t mqtt_cfg = {
		.uri = "mqtt://nakii.tech",
	};
	esp_mqtt_client_handle_t client = esp_mqtt_client_init(&mqtt_cfg);
	esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, client);
	esp_mqtt_client_start(client);
	
	
	pwm_init(PWM_PERIOD, duties, 1, pin_num);
	pwm_set_phases(phase);
	
	pwm_stop(0);
	pwm_set_duty(0, 1500);
	

	printf("pwm_task called \n");
	
	


}

//void adc_task()
//{
//	gpio_config_t io_conf_d5;
//	//disable interrupt
//	io_conf_d5.intr_type = GPIO_INTR_DISABLE;
//	//set as output mode
//	io_conf_d5.mode = GPIO_MODE_DEF_INPUT;
//	//bit mask of the pins that you want to set,e.g.GPIO15/16
//	io_conf_d5.pin_bit_mask = (1 << 16); //PIN-D5
//	//disable pull-down mode
//	io_conf_d5.pull_down_en = 0;
//	//disable pull-up mode
//	io_conf_d5.pull_up_en = 0;
//	//configure GPIO with the given settings
//	gpio_config(&io_conf_d5);
//	
//	
//	adc_config_t adc_config;
//
//	// Depend on menuconfig->Component config->PHY->vdd33_const value
//	// When measuring system voltage(ADC_READ_VDD_MODE), vdd33_const must be set to 255.
//	adc_config.mode = ADC_READ_TOUT_MODE;
//	adc_config.clk_div = 8; // ADC sample collection clock = 80MHz/clk_div = 10MHz
//
//	// ESP_ERROR_CHECK(adc_init(&adc_config));
//	adc_init(&adc_config);
//	uint16_t adc_data;
//	
//	while (1)
//	{
//		
//		//printDEBUG(DSYS, "adc read: %2.6f\r\n", Temp);
//		printf("PIN D5: %d \n", Get_KY033_Hunt(16));
//		//printf("Hello world \n");
//		
//		vTaskDelay(250 / portTICK_PERIOD_MS);
//	}
//}